[TOC]

数组的基本特点：支持随机访问

数组的关键：索引与寻址

数组必须要连续存储

**时间复杂度：**

- Lookup O(1)
- Insert O(n)
- Delete O(n)
- Append(push back) O(1)
- Prepend(push front) O(n)

**变长数组（resizable array）**

- C++: vector
- Java: ArrayList
- Python: list

如何实现一个变长数组？

- 支持索引与随机访问
- 分配多长的连续空间？
- 空间不够用了怎么办？
- 空间剩余很多如何回收？

**实现方法**

- 一个简易的实现方法
- 初始：空数组，分配常数空间
- Push back：若空间不够，重新申请2倍大小的连续空间，拷贝到新空间，释放旧空间
- Pop back：若空间利用率不到25%，释放一半的空间

**时间复杂度**

- 均摊O(1)
- 在空数组中连续插入n个元素，总插入/拷贝次数为 n + n/2 + n/4 + .... < 2n
- 一次扩容到下一次释放，至少需要再删除 (1 - 2*0.25)n=0.5n 次

**思考**

- 若释放空间的阈值设定为50%，会发生什么情况？
- 会导致释放一半空间之后，再插入会造成再次扩容，接着删除又会造成释放空间，时间复杂度会提升为O(n)



# 实战

[88.合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

主题思路：i、j两个索引，谁小放谁

细节：i和j的边界问题

```
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    	for (int i = m + n - 1; i >= 0; i--) {
    		if (n == 0 || m > 0 && nums1[m - 1] > nums2[n - 1])
    			nums1[i] = nums1[m - 1], m--;
    		else 
    			nums1[i] = nums2[n - 1], n--;
    	}
    }
};
```

[26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
		int n = 0;
		for (int i = 0; i < nums.size(); i++) {
			if (i == 0 || nums[i] != nums[i - 1]) {
				nums[n] = nums[i];
				n++;
			}
		}
		return n;
    }
};
```

[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

解法1：

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
    	int n = 0;
    	for (int i = 0; i < nums.size(); i++) 
    		if (nums[i] != 0) nums[n++] = nums[i];
    	for (; n < nums.size(); n++)
    		nums[n] = 0;
    }
};
```

解法2：

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
    	for (int l = 0, cur = 0; cur < nums.size; cur++) {
    		if (nums[cur] != 0) {
    			swap(nums[l++], nums[cur]);
    		}
    	}
    }
};
```





























































































































